# 전송계층 프로토콜

## 1. 전송계층 개요

### 1.1 전송계층의 역할

#### 기본 기능
- **종단간 통신(End-to-End Communication)** 제공
- **신뢰성 있는 데이터 전송** 보장
- **흐름 제어(Flow Control)** 및 **혼잡 제어(Congestion Control)**
- **포트 기반 멀티플렉싱/디멀티플렉싱**

#### OSI 7계층에서의 위치
- **계층 4**: Transport Layer
- **상위 계층**: 세션, 표현, 응용 계층
- **하위 계층**: 네트워크 계층 (IP)
- **주요 역할**: 프로세스 간 통신 지원

### 1.2 전송계층 서비스

#### 연결 지향 서비스 (Connection-Oriented)
- **특징**: 통신 전 연결 설정 필요
- **신뢰성**: 데이터 순서 보장, 오류 검출/정정
- **대표 프로토콜**: TCP (Transmission Control Protocol)
- **적용 분야**: 웹, 이메일, 파일 전송

#### 비연결 서비스 (Connectionless)
- **특징**: 연결 설정 없이 즉시 데이터 전송
- **효율성**: 낮은 오버헤드, 빠른 전송
- **대표 프로토콜**: UDP (User Datagram Protocol)
- **적용 분야**: 실시간 스트리밍, DNS, DHCP

## 2. TCP (Transmission Control Protocol)

### 2.1 TCP 특징

#### 주요 특성
- **연결 지향**: 3-way handshake로 연결 설정
- **신뢰성**: 순서 보장, 중복 제거, 오류 복구
- **흐름 제어**: 수신자 버퍼 크기 고려
- **혼잡 제어**: 네트워크 상태에 따른 전송 속도 조절

#### 서비스 모델
- **바이트 스트림 서비스**: 연속된 바이트 단위 전송
- **전이중 통신(Full-Duplex)**: 양방향 동시 데이터 전송
- **점대점 통신(Point-to-Point)**: 두 종단점 간 통신

### 2.2 TCP 헤더 구조

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

#### 주요 필드 설명
1. **Source/Destination Port** (16비트 각)
   - 송신/수신 애플리케이션 구분
   - 0-1023: Well-known ports
   - 1024-49151: Registered ports
   - 49152-65535: Dynamic/Private ports

2. **Sequence Number** (32비트)
   - 바이트 스트림에서의 위치 표시
   - 초기값은 임의의 수(ISN: Initial Sequence Number)

3. **Acknowledgment Number** (32비트)
   - 다음에 받기를 기대하는 바이트 번호
   - ACK 플래그가 설정된 경우에만 유효

4. **Window Size** (16비트)
   - 수신자가 받을 수 있는 데이터 크기
   - 흐름 제어를 위한 필드

5. **Control Flags** (6비트)
   - **URG**: Urgent Pointer 필드 유효성
   - **ACK**: Acknowledgment 필드 유효성
   - **PSH**: Push 기능 (즉시 전달)
   - **RST**: 연결 재설정
   - **SYN**: 연결 설정 요청
   - **FIN**: 연결 종료 요청

### 2.3 TCP 연결 관리

#### 3-Way Handshake (연결 설정)
```
Client                                Server
  |                                     |
  |  1. SYN (seq=x)                     |
  |------------------------------------>|
  |                                     |
  |  2. SYN-ACK (seq=y, ack=x+1)       |
  |<------------------------------------|
  |                                     |
  |  3. ACK (seq=x+1, ack=y+1)         |
  |------------------------------------>|
  |                                     |
  |     연결 설정 완료                   |
```

#### 4-Way Handshake (연결 종료)
```
Client                                Server
  |                                     |
  |  1. FIN (seq=x)                     |
  |------------------------------------>|
  |                                     |
  |  2. ACK (ack=x+1)                   |
  |<------------------------------------|
  |                                     |
  |  3. FIN (seq=y)                     |
  |<------------------------------------|
  |                                     |
  |  4. ACK (ack=y+1)                   |
  |------------------------------------>|
  |                                     |
  |     연결 종료 완료                   |
```

### 2.4 TCP 신뢰성 보장 메커니즘

#### 순서 제어 (Sequence Control)
- **Sequence Number**를 이용한 순서 보장
- 순서가 바뀐 패킷 재정렬
- 중복 패킷 제거

#### 오류 제어 (Error Control)
1. **체크섬(Checksum)**
   - 헤더와 데이터의 무결성 검증
   - 16비트 1의 보수 체크섬 사용

2. **확인 응답(Acknowledgment)**
   - 수신 확인을 통한 성공적 전송 보장
   - 누적 ACK 방식 사용

3. **재전송(Retransmission)**
   - 타임아웃 발생 시 자동 재전송
   - 적응적 재전송 타이머 알고리즘

#### 타임아웃 관리
- **RTT(Round Trip Time) 측정**
- **RTO(Retransmission Timeout) 계산**
- **Exponential Backoff**: 재전송 간격 지수적 증가

### 2.5 TCP 흐름 제어

#### 슬라이딩 윈도우 (Sliding Window)
- **윈도우 크기**: 수신자가 한 번에 받을 수 있는 데이터량
- **동적 조정**: 수신자의 버퍼 상태에 따라 조정
- **Zero Window**: 수신자 버퍼가 가득 찬 경우

#### 흐름 제어 메커니즘
1. **Window Advertisement**
   - 수신자가 윈도우 크기를 송신자에게 알림
   - TCP 헤더의 Window 필드 사용

2. **Window Scaling**
   - 큰 윈도우 크기 지원을 위한 확장
   - TCP 옵션으로 구현

### 2.6 TCP 혼잡 제어

#### 혼잡 제어의 필요성
- **네트워크 혼잡**: 네트워크 용량 초과로 인한 성능 저하
- **혼잡 붕괴**: 재전송 증가로 인한 성능 급격한 저하
- **공정성**: 여러 연결 간 대역폭 공정한 분배

#### 주요 알고리즘

##### 1. Slow Start
- **초기 윈도우**: 1 MSS(Maximum Segment Size)
- **지수적 증가**: RTT마다 윈도우 크기 2배 증가
- **임계값**: ssthresh(Slow Start Threshold) 도달 시 변경

##### 2. Congestion Avoidance
- **선형 증가**: RTT마다 윈도우 크기 1 증가
- **점진적 증가**: 혼잡 회피를 위한 보수적 접근

##### 3. Fast Retransmit
- **3 duplicate ACK**: 같은 ACK 3번 수신 시 즉시 재전송
- **빠른 손실 감지**: 타임아웃 대기 없이 재전송

##### 4. Fast Recovery
- **혼잡 윈도우 반감**: 손실 감지 시 cwnd를 절반으로 줄임
- **Congestion Avoidance 진입**: Slow Start 단계 생략

#### 혼잡 제어 상태 다이어그램
```
Slow Start → (cwnd >= ssthresh) → Congestion Avoidance
     ↑                                      ↓
     |                                 (3 dup ACK)
     |                                      ↓
     ← (Timeout) ← Fast Recovery ← Fast Retransmit
```

## 3. UDP (User Datagram Protocol)

### 3.1 UDP 특징

#### 주요 특성
- **비연결성**: 연결 설정 과정 없음
- **비신뢰성**: 순서 보장 없음, 손실 허용
- **단순성**: 최소한의 오버헤드
- **빠른 전송**: 즉시 전송 가능

#### 장단점
**장점**:
- 낮은 지연시간
- 적은 오버헤드
- 간단한 구현
- 브로드캐스트/멀티캐스트 지원

**단점**:
- 신뢰성 없음
- 흐름 제어 없음
- 혼잡 제어 없음

### 3.2 UDP 헤더 구조

```
 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|     Source      |   Destination   |
|      Port       |      Port       |
+--------+--------+--------+--------+
|                 |                 |
|     Length      |    Checksum     |
+--------+--------+--------+--------+
|                                   |
|          Data octets ...          |
+-----------------------------------+
```

#### 필드 설명
- **Source Port** (16비트): 송신자 포트 번호
- **Destination Port** (16비트): 수신자 포트 번호
- **Length** (16비트): UDP 헤더 + 데이터 길이
- **Checksum** (16비트): 오류 검출용 (선택사항)

### 3.3 UDP 활용 분야

#### 실시간 응용
- **스트리밍 미디어**: 음성/영상 전송
- **온라인 게임**: 빠른 반응성 요구
- **VoIP**: 음성 통화 서비스

#### 간단한 요청/응답
- **DNS**: 도메인 이름 해석
- **DHCP**: IP 주소 자동 할당
- **SNMP**: 네트워크 관리

#### 브로드캐스트/멀티캐스트
- **네트워크 검색**: 서비스 발견
- **멀티미디어 스트리밍**: IPTV, 라디오
- **시간 동기화**: NTP

## 4. 포트와 소켓

### 4.1 포트 개념

#### 포트의 역할
- **프로세스 식별**: 동일 호스트 내 여러 애플리케이션 구분
- **멀티플렉싱**: 여러 애플리케이션의 동시 통신 지원
- **서비스 식별**: 특정 서비스에 대한 표준 포트

#### 포트 번호 분류
1. **Well-Known Ports** (0-1023)
   - 시스템 예약 포트
   - 주요 서비스용 포트
   - 예: HTTP(80), HTTPS(443), FTP(21), SSH(22)

2. **Registered Ports** (1024-49151)
   - IANA 등록 포트
   - 특정 애플리케이션용
   - 예: MySQL(3306), PostgreSQL(5432)

3. **Dynamic/Private Ports** (49152-65535)
   - 클라이언트가 임시로 사용
   - 자동 할당되는 포트

### 4.2 주요 Well-Known 포트

| 포트 | 프로토콜 | 서비스 | 설명 |
|------|----------|--------|------|
| 20/21 | TCP | FTP | 파일 전송 프로토콜 |
| 22 | TCP | SSH | 보안 셸 |
| 23 | TCP | Telnet | 원격 터미널 |
| 25 | TCP | SMTP | 이메일 전송 |
| 53 | TCP/UDP | DNS | 도메인 이름 시스템 |
| 67/68 | UDP | DHCP | 동적 호스트 구성 |
| 80 | TCP | HTTP | 웹 서비스 |
| 110 | TCP | POP3 | 이메일 수신 |
| 143 | TCP | IMAP | 이메일 액세스 |
| 443 | TCP | HTTPS | 보안 웹 서비스 |
| 993 | TCP | IMAPS | 보안 IMAP |
| 995 | TCP | POP3S | 보안 POP3 |

### 4.3 소켓 프로그래밍

#### 소켓의 개념
- **정의**: 네트워크 통신을 위한 프로그래밍 인터페이스
- **구성**: IP 주소 + 포트 번호
- **역할**: 애플리케이션과 전송계층 간 인터페이스

#### TCP 소켓 프로그래밍
```python
# 서버 소켓
import socket

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 8080))
server_socket.listen(5)

while True:
    client_socket, addr = server_socket.accept()
    data = client_socket.recv(1024)
    client_socket.send(b'Hello Client')
    client_socket.close()
```

#### UDP 소켓 프로그래밍
```python
# UDP 서버
import socket

udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udp_socket.bind(('localhost', 8080))

while True:
    data, addr = udp_socket.recvfrom(1024)
    udp_socket.sendto(b'Hello UDP', addr)
```

## 5. 고급 전송계층 기술

### 5.1 TCP 확장 기능

#### TCP Window Scaling
- **목적**: 큰 윈도우 크기 지원 (64KB 이상)
- **구현**: TCP 옵션으로 스케일링 팩터 협상
- **적용**: 고속 네트워크 환경

#### TCP Selective Acknowledgment (SACK)
- **문제점**: 기존 누적 ACK의 한계
- **해결책**: 선택적 ACK로 부분 수신 정보 전달
- **효과**: 재전송 효율성 향상

#### TCP Timestamp
- **기능**: RTT 정확한 측정
- **구현**: TCP 옵션으로 타임스탬프 추가
- **장점**: 더 정확한 재전송 타이머

### 5.2 멀티패스 TCP (MPTCP)

#### 개념과 목적
- **정의**: 여러 경로를 동시에 사용하는 TCP 확장
- **목표**: 처리량 향상, 신뢰성 증대
- **표준**: RFC 6824

#### 주요 기능
1. **경로 관리**: 다중 인터페이스 관리
2. **패킷 스케줄링**: 경로별 패킷 분배
3. **혼잡 제어**: 경로별 독립적 제어

#### 적용 분야
- **모바일 기기**: WiFi + 셀룰러 동시 사용
- **데이터센터**: 다중 링크 활용
- **백본 네트워크**: 로드 밸런싱

### 5.3 QUIC (Quick UDP Internet Connections)

#### QUIC 개요
- **개발**: Google이 개발한 전송 프로토콜
- **기반**: UDP 위에 구현된 신뢰성 프로토콜
- **표준**: RFC 9000 (HTTP/3의 기반)

#### 주요 특징
1. **연결 설정 최적화**: 0-RTT 연결 재개
2. **다중 스트림**: 스트림별 독립적 전송
3. **내장 보안**: TLS 1.3 통합
4. **연결 마이그레이션**: IP 변경 시에도 연결 유지

#### QUIC vs TCP 비교
| 항목 | TCP | QUIC |
|------|-----|------|
| 기반 | IP | UDP |
| 연결 설정 | 3-way handshake | 1-RTT (0-RTT 가능) |
| 보안 | 별도 TLS | 내장 암호화 |
| 다중화 | 단일 스트림 | 다중 스트림 |
| HOL 블로킹 | 있음 | 없음 |

## 6. 성능 최적화

### 6.1 TCP 성능 요소

#### 대역폭-지연 곱 (Bandwidth-Delay Product)
- **정의**: 네트워크 용량 = 대역폭 × RTT
- **의미**: 파이프라인에 있을 수 있는 최대 데이터량
- **최적화**: 윈도우 크기를 BDP에 맞춰 조정

#### TCP 처리량 공식
```
처리량 ≤ Window Size / RTT
최대 처리량 ≈ MSS / (RTT × √(손실률))
```

### 6.2 성능 최적화 기법

#### 송신측 최적화
1. **Nagle 알고리즘**: 작은 패킷 전송 최소화
2. **TCP_NODELAY**: Nagle 알고리즘 비활성화
3. **큰 전송 오프로드**: 하드웨어 가속 활용

#### 수신측 최적화
1. **지연된 ACK**: ACK 전송 최적화
2. **윈도우 스케일링**: 큰 수신 윈도우
3. **수신 버퍼 튜닝**: 적절한 버퍼 크기 설정

#### 네트워크 최적화
1. **적절한 버퍼 크기**: 라우터/스위치 버퍼 튜닝
2. **QoS**: 트래픽 우선순위 관리
3. **로드 밸런싱**: 트래픽 분산

### 6.3 모니터링과 튜닝

#### 성능 지표
- **처리량(Throughput)**: 초당 전송 데이터량
- **지연시간(Latency)**: 패킷 전송 시간
- **패킷 손실률**: 손실된 패킷 비율
- **연결 설정 시간**: 새 연결 설정 소요 시간

#### 튜닝 도구
- **netstat**: 연결 상태 확인
- **ss**: 소켓 통계 정보
- **iperf**: 네트워크 성능 측정
- **tcpdump/Wireshark**: 패킷 분석

## 7. 보안 고려사항

### 7.1 전송계층 보안 위협

#### 주요 공격 유형
1. **TCP SYN Flooding**: SYN 패킷으로 서버 자원 고갈
2. **TCP Hijacking**: 연결 가로채기
3. **포트 스캔**: 열린 포트 탐지
4. **DoS/DDoS**: 서비스 거부 공격

#### 취약점 분석
- **시퀀스 번호 예측**: 약한 난수 생성
- **포트 예측**: 예측 가능한 포트 할당
- **타이밍 공격**: 응답 시간 분석

### 7.2 보안 대응 방안

#### TCP 보안 강화
1. **랜덤 시퀀스 번호**: 강력한 난수 생성기 사용
2. **SYN 쿠키**: SYN Flooding 대응
3. **연결 제한**: 동시 연결 수 제한
4. **포트 랜덤화**: 예측 불가능한 포트 사용

#### 방화벽과 IDS/IPS
- **상태 추적 방화벽**: 연결 상태 기반 필터링
- **침입 탐지**: 비정상 트래픽 패턴 감지
- **침입 방지**: 실시간 공격 차단

### 7.3 TLS/SSL 통합

#### TLS over TCP
- **계층 구조**: 애플리케이션 - TLS - TCP - IP
- **보안 서비스**: 암호화, 인증, 무결성
- **성능 영향**: 추가 오버헤드 고려

#### 최적화 방안
- **세션 재사용**: TLS 세션 캐싱
- **하드웨어 가속**: 암호화 전용 칩 활용
- **프로토콜 선택**: TLS 1.3 등 최신 버전 사용

## 8. 실무 응용 및 문제 해결

### 8.1 일반적인 문제와 해결

#### 연결 관련 문제
1. **연결 거부 (Connection Refused)**
   - 원인: 서버 프로세스 미실행, 방화벽 차단
   - 해결: 서비스 상태 확인, 포트 열기

2. **연결 타임아웃 (Connection Timeout)**
   - 원인: 네트워크 지연, 경로 문제
   - 해결: 라우팅 확인, 타임아웃 값 조정

3. **연결 재설정 (Connection Reset)**
   - 원인: 애플리케이션 오류, 리소스 부족
   - 해결: 로그 분석, 리소스 모니터링

#### 성능 관련 문제
1. **낮은 처리량**
   - 원인: 작은 윈도우 크기, 네트워크 혼잡
   - 해결: 윈도우 스케일링, 혼잡 제어 튜닝

2. **높은 지연시간**
   - 원인: 네트워크 경로, 버퍼링
   - 해결: 경로 최적화, 버퍼 크기 조정

### 8.2 네트워크 진단 도구

#### 연결 상태 확인
```bash
# 활성 연결 확인
netstat -an | grep :80

# 소켓 상태 확인
ss -tuln

# 프로세스별 연결 확인
lsof -i :80
```

#### 패킷 분석
```bash
# TCP 패킷 캡처
tcpdump -i eth0 tcp port 80

# 연결 설정 과정 분석
tcpdump -i eth0 tcp[tcpflags] & tcp-syn != 0
```

#### 성능 측정
```bash
# TCP 처리량 측정
iperf3 -c server_ip -t 60

# 연결 설정 시간 측정
time telnet server_ip 80
```

### 8.3 최적화 사례

#### 웹 서버 최적화
- **Keep-Alive**: 연결 재사용으로 오버헤드 감소
- **Connection Pooling**: 연결 풀 관리
- **Load Balancing**: 다중 서버 부하 분산

#### 데이터베이스 최적화
- **Connection Pooling**: DB 연결 재사용
- **Prepared Statements**: 쿼리 최적화
- **Read Replicas**: 읽기 전용 복제본 활용

이제 2부의 6장 전송계층 프로토콜이 완성되었습니다. TCP와 UDP의 상세한 동작 원리부터 최신 기술 동향, 실무 응용까지 포괄적으로 다루었습니다.

